
package it.unipi.CellMap;

import com.fasterxml.jackson.core.JsonParseException;
import com.fasterxml.jackson.databind.JsonMappingException;
import com.fasterxml.jackson.databind.exc.MismatchedInputException;
import com.fasterxml.jackson.databind.exc.UnrecognizedPropertyException;
import jakarta.servlet.http.HttpServletRequest;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.http.converter.HttpMessageNotReadableException;
import org.springframework.security.authorization.AuthorizationDeniedException;
import org.springframework.web.HttpRequestMethodNotSupportedException;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.servlet.resource.NoResourceFoundException;

import java.time.Instant;

@ControllerAdvice
public class GlobalExceptionHandler {

    private static final Logger logger = LoggerFactory.getLogger(GlobalExceptionHandler.class);

    // RFC 7807 REST API problem details format
    public static class ProblemDetails {

        // An identifier of the specific type of problem (e.g, a class name, a link to a documentation, ...)
        private String type;

        // A short, human-readable, generic summary of the problem type
        private String title;

        // The HTTP status code generated by the server
        private int status;

        // A human-readable explanation of the problem.
        // Should provide more context than the title
        private String detail;

        // A string that identifies the specific occurence of the problem (e.g., the requested URL)
        private String instance;

        private String timestamp;

        public ProblemDetails(String type, String title, int status, String detail, String instance) {
            this.type = type;
            this.title = title;
            this.status = status;
            this.detail = detail;
            this.instance = instance;
            this.timestamp = Instant.now().toString();
        }

        // Getters and setters
        public String getType() { return type; }
        public void setType(String type) { this.type = type; }
        public String getTitle() { return title; }
        public void setTitle(String title) { this.title = title; }
        public int getStatus() { return status; }
        public void setStatus(int status) { this.status = status; }
        public String getDetail() { return detail; }
        public void setDetail(String detail) { this.detail = detail; }
        public String getInstance() { return instance; }
        public void setInstance(String instance) { this.instance = instance; }
        public String getTimestamp() { return timestamp; }
        public void setTimestamp(String timestamp) { this.timestamp = timestamp; }
    }

    @ExceptionHandler(Exception.class)
    public ResponseEntity<ProblemDetails> handleGenericException(Exception ex, HttpServletRequest request) {
        logger.error("Unhandled exeception thrown: [{}] {}", ex.getClass(), ex.getMessage());
        ProblemDetails problem = new ProblemDetails(
                ex.getClass().getSimpleName(),
                "Internal server error",
                500,
                "Something went wrong, try again later",
                request.getRequestURL().toString()
        );
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                .header("Content-Type", "application/problem+json")
                .body(problem);
    }

    // If someone tries to guess the api endpoints (or uses the wrong method), simply reply with FORBIDDEN
    @ExceptionHandler({NoResourceFoundException.class, HttpRequestMethodNotSupportedException.class})
    public ResponseEntity<Void> handleNoResourceFoundException() {
        return ResponseEntity.status(HttpStatus.FORBIDDEN).build();
    }

    // FIXME: Not used right now
    // Authorization errors (i.e., a valid user/password is provided in the headers
    //  of the request, but it does not have enough privileges to execute the requested action)
    @ExceptionHandler(AuthorizationDeniedException.class)
    public ResponseEntity<ProblemDetails> handleAuthorizationDeniedException(HttpServletRequest request) {
        ProblemDetails problem = new ProblemDetails(
                "AuthorizationDeniedException",
                "Authorization denied",
                403,
                "You don't have sufficient privileges to perform this action",
                request.getRequestURL().toString()
        );
        return ResponseEntity.status(HttpStatus.FORBIDDEN)
                .header("Content-Type", "application/problem+json")
                .body(problem);
    }

    // Parse errors (e.g, name = 12)
    @ExceptionHandler(HttpMessageNotReadableException.class)
    public ResponseEntity<ProblemDetails> handleHttpMessageNotReadableException(
            HttpMessageNotReadableException ex, HttpServletRequest request) {

        Throwable cause = ex.getCause();
        String detail = "Unable to provide the details";

        if (cause instanceof UnrecognizedPropertyException unrecognized) {
            detail = String.format("Unrecognized field '%s'. Known fields are: %s",
                    unrecognized.getPropertyName(), unrecognized.getKnownPropertyIds());
        }
        else if (cause instanceof MismatchedInputException mismatched) {
            String fieldName = mismatched.getPath().isEmpty() ? "unknown" : mismatched.getPath().get(0).getFieldName();
            String expectedType = mismatched.getTargetType() != null ? mismatched.getTargetType().getSimpleName() : "unknown";
            detail = String.format(
                    "Field '%s' is invalid: expected %s",
                    fieldName, expectedType
            );
        }
        else if (cause instanceof JsonMappingException || cause instanceof JsonParseException) {
            detail = "The request body is not a valid JSON";
        }
        else {
            logger.warn("Unhandled parse error [{}]: {}", ex.getMostSpecificCause().getClass().getSimpleName(),
                    ex.getMostSpecificCause().getMessage());
        }

        ProblemDetails problem = new ProblemDetails(
                "HttpMessageNotReadableException",
                "Request parse error",
                400,
                detail,
                request.getRequestURL().toString()
        );

        return ResponseEntity.status(HttpStatus.BAD_REQUEST)
                .header("Content-Type", "application/problem+json")
                .body(problem);
    }

    // Validation errors (e.g., @Email)
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ProblemDetails> handleMethodArgumentNotValidException(
            MethodArgumentNotValidException ex, HttpServletRequest request) {

        String detail = ex.getBindingResult().getFieldError() == null ? "Unable to provide the details" :
                ex.getBindingResult().getFieldError().getDefaultMessage();

        ProblemDetails problem = new ProblemDetails(
                "MethodArgumentNotValidException",
                "Request validation error",
                400,
                detail,
                request.getRequestURL().toString()
        );

        return ResponseEntity.status(HttpStatus.BAD_REQUEST)
                .header("Content-Type", "application/problem+json")
                .body(problem);
    }

    // Conflict errors
    public static class ConflictException extends RuntimeException {
        public ConflictException(String message) { super(message); }
    }
    @ExceptionHandler(ConflictException.class)
    public ResponseEntity<ProblemDetails> handleConflictException(ConflictException ex, HttpServletRequest request) {
        ProblemDetails problem = new ProblemDetails(
                "ConflictException",
                "The request is in conflict with the current state of the data",
                409,
                ex.getMessage(),
                request.getRequestURL().toString()
        );
        return ResponseEntity.status(HttpStatus.CONFLICT)
                .header("Content-Type", "application/problem+json")
                .body(problem);
    }

    // Not found errors
    public static class NotFoundException extends RuntimeException {
        public NotFoundException(String message) { super(message); }
    }
    @ExceptionHandler(NotFoundException.class)
    public ResponseEntity<ProblemDetails> handleNotFoundException(NotFoundException ex, HttpServletRequest request) {
        ProblemDetails problem = new ProblemDetails(
                "NotFoundException",
                "Resource not found",
                404,
                ex.getMessage(),
                request.getRequestURL().toString()
        );
        return ResponseEntity.status(HttpStatus.NOT_FOUND)
                .header("Content-Type", "application/problem+json")
                .body(problem);
    }
}
